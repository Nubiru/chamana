# Guías de Migración

## Resumen General

Esta página documenta el proceso de migración de datos entre fases de normalización. Cada migración transforma la estructura y datos de la fase anterior a la nueva forma normal.

**Migraciones Disponibles**:

1. Fase 0 → Fase 1 (Pre-normalizado → 1NF)
2. Fase 1 → Fase 2 (1NF → 2NF)

---

## Fase 0 → Fase 1: Migración a Primera Forma Normal

### Objetivo

Transformar datos pre-normalizados a 1NF separando valores compuestos y eliminando redundancia.

### Cambios Estructurales

| Aspecto                     | Fase 0                      | Fase 1                                             |
| --------------------------- | --------------------------- | -------------------------------------------------- |
| **Tablas**                  | 3                           | 9 (+6)                                             |
| **Prendas.nombre_completo** | "Gaia - Jersey Bordó"       | diseno_id=1, tela_id=5                             |
| **Prendas.tela_nombre**     | "Jersey Bordó" (redundante) | tela_id=5 (FK única)                               |
| **Colecciones**             | No existe                   | Sistema estacional (años, temporadas, colecciones) |

---

### Proceso de Migración

#### Paso 1: Crear Nuevas Tablas

```bash
cd 1.normalizacion/database/scripts
node 02_crear_tablas.js
```

**Resultado**:

- ✅ 9 tablas creadas
- ✅ FKs establecidas
- ✅ Constraints activos

---

#### Paso 2: Insertar Datos Estáticos

```bash
node 03_insertar_estaticos.js
```

**Acciones**:

1. Crear años (2024, 2025)
2. Crear temporadas (Verano, Invierno, Otoño, Primavera)
3. Crear colecciones ("Verano 2024", "Invierno 2025")

**Resultado**:

- ✅ 2 años
- ✅ 4 temporadas
- ✅ 2 colecciones iniciales

---

#### Paso 3: Migrar Clientes y Categorías

```bash
node 04_migrar_clientes_categorias.js
```

**SQL Interno**:

```sql
-- Migrar clientes (sin cambios estructurales)
INSERT INTO chamana_db_fase1.clientes
SELECT * FROM chamana_db_fase0.clientes;

-- Migrar categorías (sin cambios estructurales)
INSERT INTO chamana_db_fase1.categorias
SELECT * FROM chamana_db_fase0.categorias;
```

**Resultado**:

- ✅ 20 clientes migrados
- ✅ 5 categorías migradas

---

#### Paso 4: Extraer Diseños y Telas

```bash
node 05_extraer_disenos_telas.js
```

**Lógica de Extracción**:

```javascript
// Desde chamana_db_fase0.prendas.nombre_completo
// Ejemplo: "Gaia - Jersey Bordó"

const [diseno, tela] = nombre_completo.split(' - ');
// diseno = "Gaia"
// tela = "Jersey Bordó"

// Insertar en tablas nuevas
INSERT INTO disenos (nombre) VALUES ('Gaia') ON CONFLICT DO NOTHING;
INSERT INTO telas (nombre) VALUES ('Jersey Bordó') ON CONFLICT DO NOTHING;
```

**Parseo de Telas** (tipo_tela y color):

```javascript
// Ejemplo: "Jersey Bordó"
const palabras = tela.split(' ');
const tipo_tela = palabras[0]; // "Jersey"
const color = palabras.slice(1).join(' '); // "Bordó"
```

**Resultado**:

- ✅ 8 diseños únicos extraídos
- ✅ 25+ telas únicas extraídas
- ✅ Tipo de tela y color parseados

---

#### Paso 5: Migrar Prendas con Nuevas Relaciones

```bash
node 06_migrar_prendas.js
```

**SQL Complejo**:

```sql
INSERT INTO chamana_db_fase1.prendas (
    diseno_id, tela_id, categoria_id, coleccion_id,
    precio_chamana, precio_arro, descuento_porcentaje, stock
)
SELECT
    d.diseno_id,
    t.tela_id,
    p.categoria_id,
    (SELECT coleccion_id FROM colecciones WHERE nombre = 'Verano 2024' LIMIT 1),
    p.precio_chamana,
    p.precio_arro,
    p.descuento_porcentaje,
    p.stock
FROM chamana_db_fase0.prendas p
CROSS JOIN LATERAL (
    SELECT diseno_id FROM disenos
    WHERE nombre = SPLIT_PART(p.nombre_completo, ' - ', 1)
) d
CROSS JOIN LATERAL (
    SELECT tela_id FROM telas
    WHERE nombre = SPLIT_PART(p.nombre_completo, ' - ', 2)
) t;
```

**Resultado**:

- ✅ 31 prendas migradas
- ✅ Todas con FKs válidas (diseno_id, tela_id, coleccion_id)

---

#### Paso 6: Verificar Integridad

```bash
node 07_verificar.js
```

**Verificaciones**:

1. Conteo de registros coincide
2. Todas las FKs válidas (no hay huérfanos)
3. Constraint UNIQUE `(diseno_id, tela_id)` respetado
4. Stock total se preserva

---

### Transformaciones de Datos

#### Ejemplo: Prenda Individual

**Antes (Fase 0)**:

```sql
prenda_id: 1
nombre_completo: "Gaia - Jersey Bordó"
tela_nombre: "Jersey Bordó"
categoria_id: 1
precio_chamana: 40000.00
stock: 1
```

**Después (Fase 1)**:

```sql
prenda_id: 1
diseno_id: 1         -- FK → disenos.nombre = "Gaia"
tela_id: 5           -- FK → telas.nombre = "Jersey Bordó"
categoria_id: 1      -- FK preservada
coleccion_id: 1      -- FK → colecciones.nombre = "Verano 2024"
precio_chamana: 40000.00
stock: 1
```

**Tablas Nuevas Pobladas**:

```sql
-- disenos
diseno_id: 1, nombre: "Gaia"

-- telas
tela_id: 5, nombre: "Jersey Bordó", tipo_tela: "Jersey", color: "Bordó"
```

---

### Desafíos y Soluciones

#### Desafío 1: Parsing de `nombre_completo`

**Problema**: Formato no siempre consistente.

**Solución**:

```javascript
// Lógica robusta
const partes = nombre_completo.split(' - ');
if (partes.length !== 2) {
  console.error(`Formato inválido: ${nombre_completo}`);
  // Manejo de error o corrección manual
}
```

#### Desafío 2: Telas con Nombres Similares

**Problema**: "Jersey Verde", "Jersey Verde Musgo" son telas diferentes.

**Solución**: UNIQUE constraint en `telas.nombre` previene duplicados exactos. Nombres similares se crean como telas separadas.

#### Desafío 3: Colección por Defecto

**Problema**: Fase 0 no tenía concepto de colección.

**Solución**: Asignar todas las prendas a "Verano 2024" por defecto, ajustar manualmente después si es necesario.

---

## Fase 1 → Fase 2: Migración a Segunda Forma Normal

### Objetivo

Expandir de 1NF a 2NF introduciendo sistema e-commerce completo con junction tables, inventario automático y auditoría.

### Cambios Estructurales

| Aspecto                | Fase 1    | Fase 2                                                      |
| ---------------------- | --------- | ----------------------------------------------------------- |
| **Tablas**             | 9         | 12 (+3)                                                     |
| **Prendas.stock**      | Manual    | stock_inicial + stock_vendido + stock_disponible (generada) |
| **Sistema Pedidos**    | No existe | `pedidos` + `pedidos_prendas` (junction)                    |
| **Auditoría**          | No existe | `movimientos_inventario`                                    |
| **Telas Estacionales** | No existe | `telas_temporadas` (junction)                               |

---

### Proceso de Migración

#### Paso 1: Crear Nuevas Tablas y Triggers

```bash
cd 2.relaciones/database/scripts
node 02_crear_tablas.js
```

**Resultado**:

- ✅ 12 tablas creadas
- ✅ Trigger `actualizar_stock_pedido` instalado
- ✅ Columna generada `stock_disponible` activa

---

#### Paso 2: Crear Índices

```bash
node 03_crear_indices.js
```

**Índices Creados**:

- FKs en todas las tablas nuevas
- Índices compuestos en junction tables

---

#### Paso 3: Migrar Datos desde Fase 1

```bash
node 04_migrar_datos_fase1.js
```

**SQL Interno**:

```sql
-- Migrar clientes, categorías, diseños, telas (sin cambios)
INSERT INTO chamana_db_fase2.clientes SELECT * FROM chamana_db_fase1.clientes;
-- ... (similar para otras tablas)

-- Migrar prendas con transformación de stock
INSERT INTO chamana_db_fase2.prendas (
    diseno_id, tela_id, categoria_id, coleccion_id,
    precio_chamana, precio_arro, descuento_porcentaje,
    stock_inicial, stock_vendido  -- ✅ TRANSFORMACIÓN
)
SELECT
    diseno_id, tela_id, categoria_id, coleccion_id,
    precio_chamana, precio_arro, descuento_porcentaje,
    stock,  -- → stock_inicial
    0       -- → stock_vendido (asumimos inicio limpio)
FROM chamana_db_fase1.prendas;
-- stock_disponible se calcula automáticamente
```

**Resultado**:

- ✅ Todos los datos migrados
- ✅ `stock` transformado a `stock_inicial` + `stock_vendido`
- ✅ `stock_disponible` generado automáticamente

---

#### Paso 4: Inicializar Telas Estacionales

```bash
node 05_inicializar_telas_temporadas.js
```

**Lógica**:

```sql
-- Crear disponibilidad para todas las telas en todas las temporadas
INSERT INTO telas_temporadas (tela_id, año_id, temporada_id, disponible)
SELECT
    t.tela_id,
    a.año_id,
    temp.temporada_id,
    TRUE  -- Todas disponibles por defecto
FROM telas t
CROSS JOIN años a
CROSS JOIN temporadas temp;
```

**Resultado**:

- ✅ Matriz completa de disponibilidad creada
- ✅ Todas las telas disponibles en todas las temporadas inicialmente

---

#### Paso 5: Generar Pedidos de Prueba

```bash
node 06_generar_pedidos_prueba.js
```

**Lógica**:

```javascript
// Crear 5-10 pedidos aleatorios
for (let i = 0; i < 10; i++) {
  const cliente_id = randomInt(1, 20);
  const pedido = await crearPedido(cliente_id);

  // Agregar 1-3 productos al pedido
  const num_items = randomInt(1, 3);
  for (let j = 0; j < num_items; j++) {
    const prenda_id = randomInt(1, 31);
    const cantidad = randomInt(1, 2);
    await agregarItemPedido(pedido.pedido_id, prenda_id, cantidad);
    // Trigger automático actualiza stock y auditoría
  }
}
```

**Resultado**:

- ✅ 10 pedidos de prueba
- ✅ Stock actualizado automáticamente
- ✅ Movimientos de inventario registrados

---

#### Paso 6: Verificar Sistema Completo

```bash
node 07_verificar.js
```

**Verificaciones**:

1. Stock disponible = stock_inicial - stock_vendido (columna generada correcta)
2. Movimientos de inventario coinciden con pedidos
3. Todas las FKs válidas
4. Triggers funcionando correctamente

---

### Transformaciones de Datos

#### Ejemplo: Prenda con Stock

**Antes (Fase 1)**:

```sql
prenda_id: 1
diseno_id: 1
tela_id: 5
precio_chamana: 40000.00
stock: 3  -- Campo manual
```

**Después (Fase 2)**:

```sql
prenda_id: 1
diseno_id: 1
tela_id: 5
precio_chamana: 40000.00
stock_inicial: 3       -- Migrado desde 'stock'
stock_vendido: 0       -- Inicializado en 0
stock_disponible: 3    -- Generado: 3 - 0 = 3
```

**Después de Venta** (automático con trigger):

```sql
-- Se crea pedido con 2 unidades de prenda_id=1
-- Trigger actualiza:
stock_vendido: 2
stock_disponible: 1  -- Recalculado: 3 - 2 = 1

-- Auditoría registrada en movimientos_inventario:
movimiento_id: 1
prenda_id: 1
tipo_movimiento: 'salida'
cantidad: 2
stock_anterior: 3
stock_nuevo: 1
motivo: 'Venta - Pedido #101'
```

---

### Desafíos y Soluciones

#### Desafío 1: Transformación de Stock

**Problema**: Fase 1 tenía un solo campo `stock`, Fase 2 necesita `stock_inicial` + `stock_vendido`.

**Solución**: Asumir `stock` de Fase 1 = `stock_inicial`, inicializar `stock_vendido = 0`. Esto implica que todo el stock es nuevo (no hay ventas previas).

**Limitación**: No se preserva historial de ventas previas (si existieran en realidad).

#### Desafío 2: Triggers en Desarrollo

**Problema**: Debugging de triggers es difícil.

**Solución**:

- Logs detallados en función trigger
- Verificación manual de resultados después de cada inserción de pedido
- Rollback completo de DB si hay errores

#### Desafío 3: Inicialización de Junction Tables

**Problema**: `telas_temporadas` requiere combinaciones de 25 telas × 2 años × 4 temporadas = 200 registros.

**Solución**: Script automatizado con `CROSS JOIN` para generar matriz completa.

---

## Rollback de Migraciones

### Fase 1 → Fase 0 (No Recomendado)

**Pérdida de Datos**:

- ❌ Se pierde separación de diseños y telas
- ❌ Se pierde sistema de colecciones
- ❌ Requiere reconstruir `nombre_completo` y `tela_nombre`

**No implementado**: Rollback implica pérdida de normalización, no tiene sentido pedagógico.

### Fase 2 → Fase 1 (Posible con Limitaciones)

**SQL Hipotético**:

```sql
-- Migrar prendas de vuelta
INSERT INTO chamana_db_fase1.prendas (
    diseno_id, tela_id, categoria_id, coleccion_id,
    precio_chamana, precio_arro, descuento_porcentaje,
    stock
)
SELECT
    diseno_id, tela_id, categoria_id, coleccion_id,
    precio_chamana, precio_arro, descuento_porcentaje,
    stock_disponible  -- Usar stock actual
FROM chamana_db_fase2.prendas;
```

**Pérdida de Datos**:

- ❌ Pedidos completos (no existe en Fase 1)
- ❌ Auditoría de movimientos
- ❌ Disponibilidad estacional de telas

---

## Enlaces Relacionados

- [← Volver al Inicio del Wiki](Home)
- [Documentación de Esquemas](3.1.Documentacion-Esquemas)
- [Fase 0: Pre-Normalizado](2.1.Fase-0-Pre-Normalizado)
- [Fase 1: Primera Forma Normal](2.2.Fase-1-Primera-Forma-Normal)
- [Fase 2: Segunda Forma Normal](2.3.Fase-2-Segunda-Forma-Normal)
- [Decisiones de Diseño](3.3.Decisiones-Diseno)

---

**Última Actualización**: 23 de Octubre, 2025  
**Fuentes**: Scripts de migración en `database/scripts/` de cada fase

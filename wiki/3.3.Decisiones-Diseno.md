# Decisiones de Diseño

## Resumen General

Esta página documenta las decisiones arquitectónicas y de diseño tomadas durante el desarrollo del proyecto, con justificaciones técnicas y trade-offs considerados.

---

## Decisiones Estratégicas

### 1. Fases Independientes con Bases de Datos Separadas

**Decisión**: Crear una base de datos independiente por fase (`chamana_db_fase0`, `chamana_db_fase1`, `chamana_db_fase2`).

**Alternativas Consideradas**:

- Usar una sola DB con esquemas (schemas) PostgreSQL separados
- Usar una sola DB con prefijos de tabla (`fase0_prendas`, `fase1_prendas`)

**Justificación**:

- ✅ **Aislamiento Completo**: No hay riesgo de interferencia entre fases
- ✅ **Comparación Side-by-Side**: Evaluador puede consultar ambas fases simultáneamente
- ✅ **Rollback Seguro**: Eliminar una fase no afecta otras
- ✅ **Claridad Pedagógica**: Cada fase es una "versión" completa del sistema

**Trade-offs**:

- ❌ **Duplicación de Datos**: Clientes y categorías replicados en cada fase
- ❌ **Overhead de Storage**: ~3x espacio vs. DB única

**Conclusión**: El beneficio pedagógico y de evaluación supera el costo de storage.

---

### 2. Denormalización Intencional en Fase 0

**Decisión**: Crear Fase 0 con redundancia intencional (`nombre_completo`, `tela_nombre` repetido).

**Justificación**:

- ✅ **Punto de Partida Claro**: Muestra "qué NO hacer" antes de normalizar
- ✅ **Contraste Visual**: Problemas son obvios para evaluadores
- ✅ **Motivación Pedagógica**: Justifica la necesidad de normalización

**Trade-offs**:

- ❌ **No es Realista**: Ningún sistema real se diseñaría así intencionalmente
- ✅ **Pero es Pedagógico**: El objetivo es enseñar, no producción inmediata

**Conclusión**: Apropiado para contexto académico.

---

### 3. Datos Reales vs. Datos Ficticios

**Decisión**:

- **Productos**: Datos reales de CHAMANA (nombres, precios, telas)
- **Clientes**: Datos ficticios (nombres genéricos, emails inventados)

**Justificación**:

- ✅ **Relevancia de Negocio**: Productos reales demuestran caso de uso auténtico
- ✅ **Privacidad de Clientes**: Datos ficticios evitan problemas legales/éticos
- ✅ **Escalabilidad**: 20 clientes ficticios suficientes para pruebas

**Alternativa Considerada**: Todo ficticio (productos + clientes).

**Por qué no**: Perdería autenticidad del negocio real, menos valor como portfolio.

---

## Decisiones de Normalización

### 4. Separación de Diseño y Tela (Fase 1)

**Decisión**: Crear tablas independientes `disenos` y `telas`, relacionadas en `prendas`.

**Justificación Teórica (1NF)**:

- ✅ **Atomicidad**: `nombre_completo = "Gaia - Jersey Bordó"` es valor compuesto
- ✅ **Eliminar Redundancia**: "Jersey Bordó" se repite múltiples veces

**Justificación de Negocio**:

- ✅ **Flexibilidad**: Agregar nuevos diseños sin afectar telas
- ✅ **Gestión Separada**: Diseñador puede trabajar en diseños, proveedor en telas
- ✅ **Búsquedas Eficientes**: Filtrar por tela o diseño directamente

**Trade-offs**:

- ❌ **Queries Más Complejos**: Requiere JOIN para mostrar "nombre completo"
- ❌ **Performance**: JOINs son más lentos que campos simples

**Conclusión**: El trade-off es aceptable. Performance se puede optimizar con índices.

---

### 5. Sistema de Colecciones Estacionales (Fase 1)

**Decisión**: Introducir tablas `años`, `temporadas`, `colecciones` en Fase 1.

**Alternativas Consideradas**:

- Agregar campos `año` y `temporada` directamente en `prendas`
- No implementar sistema de colecciones (más simple)

**Justificación**:

- ✅ **Escalabilidad**: Fácil agregar nuevas temporadas/años
- ✅ **Reutilización**: Temporadas se definen una vez, se reutilizan cada año
- ✅ **Queries Avanzados**: "Dame todas las prendas de Verano 2024"

**Trade-offs**:

- ❌ **Complejidad Temprana**: Fase 1 ya tiene 9 tablas (quizás demasiado)
- ✅ **Pero Justificado**: Necesario para negocio real de moda con colecciones

**Conclusión**: Apropiado para caso de uso CHAMANA.

---

### 6. Junction Table `pedidos_prendas` (Fase 2)

**Decisión**: Crear tabla intermedia en lugar de FK directa en `prendas`.

**Justificación Teórica (2NF)**:

- ✅ **Relación N:M**: Un pedido tiene múltiples prendas, una prenda puede estar en múltiples pedidos
- ✅ **Atributos de Relación**: `cantidad`, `precio_unitario` son propios de la relación, no de prenda ni pedido

**Alternativa Considerada**: Array de `prenda_id` en tabla `pedidos` (no relacional).

**Por qué no**: PostgreSQL soporta arrays, pero violaría principios relacionales y dificulta queries.

**Conclusión**: Junction table es solución estándar y correcta.

---

### 7. Columna Generada `stock_disponible` (Fase 2)

**Decisión**: `stock_disponible GENERATED ALWAYS AS (stock_inicial - stock_vendido) STORED`.

**Alternativas Consideradas**:

- Campo manual `stock` (como Fase 0/1)
- Vista calculada (no almacenada)
- Trigger para actualizar `stock_disponible`

**Justificación**:

- ✅ **Integridad Garantizada**: No se puede editar manualmente, siempre consistente
- ✅ **Performance**: STORED = pre-calculado, no requiere cálculo en query
- ✅ **Simplicidad**: PostgreSQL maneja la lógica automáticamente

**Trade-offs**:

- ❌ **Feature PostgreSQL 12+**: No portable a otros RDBMS antiguos
- ✅ **Pero OK**: Requisito es PostgreSQL 15+

**Conclusión**: Mejor práctica moderna para campos calculados.

---

### 8. Junction Table `telas_temporadas` (Fase 2)

**Decisión**: Crear tabla para gestionar disponibilidad de telas por temporada/año.

**Justificación de Negocio**:

- ✅ **Realismo**: Moda tiene telas estacionales (lana en invierno, lino en verano)
- ✅ **Gestión de Inventario**: Saber qué telas pedir para próxima temporada

**Alternativa Considerada**: No implementar (simplificar).

**Por qué sí**: Agrega realismo al sistema, demuestra comprensión de dominio de negocio.

**Trade-offs**:

- ❌ **Complejidad Adicional**: Otra junction table
- ✅ **Pero Justificado**: Feature valiosa para negocio real

---

## Decisiones de Implementación

### 9. Node.js + Express Backend

**Decisión**: Backend REST API con Node.js y Express.

**Alternativas Consideradas**:

- Python + Flask/Django
- Java + Spring Boot
- PHP + Laravel

**Justificación**:

- ✅ **JavaScript Fullstack**: Mismo lenguaje frontend/backend
- ✅ **Ecosystem Rich**: npm tiene drivers PostgreSQL maduros
- ✅ **Performance Adecuada**: Suficiente para escala del proyecto
- ✅ **Familiaridad**: Stack común en industria

**Trade-offs**:

- ❌ **Tipado Débil**: JavaScript no tiene tipos estáticos (podría usar TypeScript)
- ✅ **Aceptable**: Proyecto de escala pequeña

---

### 10. Vanilla JavaScript Frontend (Sin Frameworks)

**Decisión**: Frontend con HTML/CSS/JS puro, sin React/Vue/Angular.

**Justificación**:

- ✅ **Claridad Pedagógica**: No hay "magia" de frameworks
- ✅ **Foco en DB**: Proyecto es sobre bases de datos, no frontend moderno
- ✅ **Simplicidad**: Menos dependencias, setup más rápido

**Trade-offs**:

- ❌ **Menos Moderno**: No demuestra habilidades en frameworks populares
- ✅ **Pero Apropiado**: Proyecto académico de DB, no frontend showcase

**Conclusión**: Decisión consciente de simplicidad.

---

### 11. Triggers vs. Lógica en Aplicación

**Decisión**: Usar trigger PostgreSQL para actualizar stock automáticamente (Fase 2).

**Alternativas Consideradas**:

- Lógica en backend Node.js (transacciones manuales)
- Stored procedures llamados desde backend

**Justificación**:

- ✅ **Integridad Garantizada**: Trigger siempre se ejecuta, incluso si múltiples apps acceden DB
- ✅ **Performance**: Operación en DB es más rápida que roundtrip a app
- ✅ **Centralización**: Lógica de negocio crítica en DB (single source of truth)

**Trade-offs**:

- ❌ **Portabilidad**: Triggers no son fáciles de migrar a otro RDBMS
- ❌ **Debugging**: Más difícil que código de aplicación
- ✅ **Aceptable**: PostgreSQL es requisito fijo del proyecto

**Conclusión**: Apropiado para integridad crítica de inventario.

---

### 12. Scripts de Migración Automatizados

**Decisión**: Script maestro `00_db.js` que ejecuta todos los pasos en orden.

**Alternativas Consideradas**:

- Scripts SQL puros (sin Node.js)
- Migrations tools (Sequelize, Knex, Liquibase)

**Justificación**:

- ✅ **Simplicidad**: Un comando ejecuta todo (`node 00_db.js`)
- ✅ **Control Total**: Lógica personalizada en JavaScript
- ✅ **Logging Detallado**: Feedback en tiempo real

**Trade-offs**:

- ❌ **No es Herramienta Estándar**: Migrations tools ofrecen rollback automático
- ✅ **Suficiente para Proyecto**: No necesita rollback (DB independientes por fase)

---

## Decisiones de Naming Conventions

### 13. Español para Nombres de Tablas/Columnas

**Decisión**: Usar español para nombres en DB (`clientes`, `prendas`, `telas`, `años`).

**Justificación**:

- ✅ **Dominio en Español**: Negocio es argentino/hispanohablante
- ✅ **Claridad de Dominio**: "años" es más claro que "years" para stakeholders locales

**Alternativa Considerada**: Inglés (estándar internacional).

**Trade-offs**:

- ❌ **Menos Portable**: Desarrolladores internacionales prefieren inglés
- ✅ **Apropiado para Contexto**: Proyecto académico en universidad hispanohablante

**Conclusión**: Decisión de dominio sobre convención técnica.

---

### 14. Snake_case vs. camelCase

**Decisión**: `snake_case` para tablas/columnas DB, `camelCase` para JavaScript.

**Justificación**:

- ✅ **Convención PostgreSQL**: snake_case es estándar SQL
- ✅ **Convención JavaScript**: camelCase es estándar JS
- ✅ **Separación Clara**: Diferencia entre código DB y código app

**Alternativa**: Usar camelCase en ambos lados (mapeo automático).

**Por qué no**: Requiere ORM (Sequelize), agrega complejidad innecesaria.

---

## Decisiones de Seguridad

### 15. Helmet.js para Security Headers

**Decisión**: Usar middleware Helmet en Express.

**Justificación**:

- ✅ **Best Practice**: Establece headers HTTP seguros (XSS, clickjacking, etc.)
- ✅ **Fácil**: Una línea de código (`app.use(helmet())`)

**Trade-offs**: Ninguno significativo.

---

### 16. No Implementar Autenticación (Por Ahora)

**Decisión**: No hay login/registro en Fases 0-2.

**Justificación**:

- ✅ **Foco en DB**: Proyecto es sobre normalización, no seguridad
- ✅ **Planeado para Fase 3+**: Autenticación/roles vendrán después

**Trade-offs**:

- ❌ **No es Production-Ready**: Sistema actual es inseguro para producción
- ✅ **Apropiado para Desarrollo**: Setup rápido, fácil testing

---

## Lecciones Aprendidas

### 17. Prefiero Normalización sobre Performance (Por Ahora)

**Observación**: Fase 2 requiere muchos JOINs para queries simples.

**Decisión Futura**: Fase 4 (Optimización) introducirá:

- Índices específicos para queries frecuentes
- Vistas materializadas para agregaciones
- Potencialmente denormalización controlada en casos específicos

**Conclusión**: Normalizar primero, optimizar después (después de profiling).

---

### 18. Documentación es Tan Importante como Código

**Observación**: Sin diagramas MER/DER, sería difícil evaluar proyecto.

**Decisión**: Invertir tiempo en:

- Diagramas Mermaid detallados
- READMEs concisos pero informativos
- GitHub Wiki para documentación exhaustiva

**Conclusión**: Documentación profesional eleva calidad percibida del proyecto.

---

## Trade-offs Generales Aceptados

| Decisión                     | Ventaja                        | Desventaja             | Aceptable?        |
| ---------------------------- | ------------------------------ | ---------------------- | ----------------- |
| Fases con DBs independientes | Aislamiento, comparación fácil | Duplicación de datos   | ✅ Sí             |
| Triggers para inventario     | Integridad garantizada         | Debugging difícil      | ✅ Sí             |
| Vanilla JS (sin frameworks)  | Simplicidad pedagógica         | Menos moderno          | ✅ Sí             |
| Nombres en español           | Claridad de dominio            | Menos portable         | ✅ Sí             |
| No autenticación (aún)       | Setup rápido, foco en DB       | No production-ready    | ✅ Sí (por ahora) |
| Columna generada stock       | Consistencia automática        | Feature PostgreSQL 12+ | ✅ Sí             |

---

## Futuras Decisiones (Fases 3+)

### Pendiente: Optimización de Performance

- Identificar queries lentos con `EXPLAIN ANALYZE`
- Crear índices específicos
- Considerar vistas materializadas

### Pendiente: Autenticación y Roles

- JWT tokens para sesiones
- Roles: Admin, Vendedor, Cliente
- Middleware de autorización

### Pendiente: Deployment en Producción

- Dockerización
- CI/CD con GitHub Actions
- Hosting (Railway, Render, AWS)

---

## Enlaces Relacionados

- [← Volver al Inicio del Wiki](Home)
- [Documentación de Esquemas](3.1.Documentacion-Esquemas)
- [Guías de Migración](3.2.Guias-Migracion)
- [Visión General del Proyecto](1.Vision-General-Proyecto)

---

**Última Actualización**: 23 de Octubre, 2025  
**Fuente**: Decisiones tomadas durante Fases 0-2  
**Estado**: Documento vivo (se actualizará en fases futuras)

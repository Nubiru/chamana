# Fase 2: Relaciones - Segunda Forma Normal (2NF)

## Objetivo

Lograr **Segunda Forma Normal (2NF)** eliminando dependencias parciales mediante junction tables correctas. Expande el sistema de Fase 1 (9 tablas) a un e-commerce completo (12 tablas) con sistema de pedidos, gestión automática de inventario, auditoría de movimientos y disponibilidad estacional de telas.

### Criterios de 2NF

Una tabla está en 2NF si:

1. ✅ **Está en 1NF** (valores atómicos, sin grupos repetitivos)
2. ✅ **No hay dependencias parciales** (todos los atributos no-clave dependen de **toda** la clave primaria, no de parte de ella)
3. ✅ **Junction tables para relaciones N:M** (muchos-a-muchos)

**Nota**: Si la clave primaria es simple (una sola columna), no puede haber dependencias parciales, por lo que 1NF = 2NF automáticamente. En esta fase, creamos junction tables apropiadas para relaciones complejas.

---

## Esquema de Base de Datos

**Nombre de Base de Datos**: `chamana_db_fase2`  
**Forma Normal**: 2NF (Segunda Forma Normal)  
**Tablas**: 12 (expansión desde 9)

### Tablas Nuevas

#### 1. `pedidos` - Órdenes de Compra

```sql
CREATE TABLE pedidos (
    pedido_id SERIAL PRIMARY KEY,
    cliente_id INTEGER REFERENCES clientes(cliente_id),
    fecha_pedido TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    estado VARCHAR(20) DEFAULT 'pendiente',  -- pendiente, confirmado, enviado, entregado, cancelado
    total DECIMAL(10,2),
    notas TEXT,
    fecha_actualizacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Propósito**: Gestionar órdenes de compra de clientes.

**Estados Posibles**:

- `pendiente`: Orden creada, esperando confirmación
- `confirmado`: Orden confirmada, preparando envío
- `enviado`: Paquete en tránsito
- `entregado`: Orden completada
- `cancelado`: Orden cancelada

---

#### 2. `pedidos_prendas` - Junction Table para Pedidos

```sql
CREATE TABLE pedidos_prendas (
    pedido_prenda_id SERIAL PRIMARY KEY,
    pedido_id INTEGER REFERENCES pedidos(pedido_id),
    prenda_id INTEGER REFERENCES prendas(prenda_id),
    cantidad INTEGER NOT NULL CHECK (cantidad > 0),
    precio_unitario DECIMAL(10,2) NOT NULL,
    subtotal DECIMAL(10,2),
    fecha_agregado TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- ✅ Constraint: Una prenda una vez por pedido
    UNIQUE(pedido_id, prenda_id)
);
```

**Propósito**: Relación N:M entre pedidos y prendas.

**Razón 2NF**: Sin esta tabla, tendríamos dependencias parciales en una tabla con clave compuesta `(pedido_id, prenda_id)`.

---

#### 3. `movimientos_inventario` - Auditoría de Stock

```sql
CREATE TABLE movimientos_inventario (
    movimiento_id SERIAL PRIMARY KEY,
    prenda_id INTEGER REFERENCES prendas(prenda_id),
    tipo_movimiento VARCHAR(20) NOT NULL,  -- entrada, salida, ajuste
    cantidad INTEGER NOT NULL,
    stock_anterior INTEGER NOT NULL,
    stock_nuevo INTEGER NOT NULL,
    motivo TEXT,
    pedido_prenda_id INTEGER REFERENCES pedidos_prendas(pedido_prenda_id),
    fecha_movimiento TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Propósito**: Registro completo de todos los cambios de stock (trazabilidad).

**Tipos de Movimiento**:

- `entrada`: Ingreso de stock (compra, devolución)
- `salida`: Reducción de stock (venta, ajuste)
- `ajuste`: Corrección manual de inventario

---

#### 4. `telas_temporadas` - Junction Table para Disponibilidad Estacional

```sql
CREATE TABLE telas_temporadas (
    tela_temporada_id SERIAL PRIMARY KEY,
    tela_id INTEGER REFERENCES telas(tela_id),
    año_id INTEGER REFERENCES años(año_id),
    temporada_id INTEGER REFERENCES temporadas(temporada_id),
    disponible BOOLEAN DEFAULT TRUE,
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- ✅ Constraint: Una combinación tela+año+temporada única
    UNIQUE(tela_id, año_id, temporada_id)
);
```

**Propósito**: Gestionar qué telas están disponibles en cada temporada/año.

**Razón 2NF**: Elimina dependencia parcial si estuviera en tabla con clave compuesta.

**Ejemplo**:

```
tela            | año  | temporada | disponible
----------------+------+-----------+-----------
Jersey Bordó    | 2024 | Verano    | ✅
Plush Verde     | 2024 | Invierno  | ✅
Coral Negro     | 2025 | Verano    | ❌
```

---

### Tablas Modificadas

#### 5. `prendas` (Actualizada para Inventario Automático)

```sql
CREATE TABLE prendas (
    prenda_id SERIAL PRIMARY KEY,
    diseno_id INTEGER REFERENCES disenos(diseno_id),
    tela_id INTEGER REFERENCES telas(tela_id),
    categoria_id INTEGER REFERENCES categorias(categoria_id),
    coleccion_id INTEGER REFERENCES colecciones(coleccion_id),
    precio_chamana DECIMAL(10,2) NOT NULL,
    precio_arro DECIMAL(10,2),
    descuento_porcentaje DECIMAL(5,2),

    -- ✅ NUEVO: Sistema de inventario automático
    stock_inicial INTEGER DEFAULT 0,
    stock_vendido INTEGER DEFAULT 0,
    stock_disponible INTEGER GENERATED ALWAYS AS (stock_inicial - stock_vendido) STORED,

    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    activo BOOLEAN DEFAULT TRUE,
    UNIQUE(diseno_id, tela_id)
);
```

**Cambios Clave**:

- ❌ **Removido**: `stock` (campo manual propenso a errores)
- ✅ **Añadido**: `stock_inicial` (inventario de entrada)
- ✅ **Añadido**: `stock_vendido` (contador de salidas)
- ✅ **Añadido**: `stock_disponible` (columna generada automáticamente)

**Ventaja**: `stock_disponible` se calcula automáticamente, eliminando riesgo de inconsistencias.

---

#### 6-12. Otras Tablas (Sin cambios estructurales)

- `clientes` - Sin cambios
- `categorias` - Sin cambios
- `disenos` - Sin cambios
- `telas` - Sin cambios
- `años` - Sin cambios
- `temporadas` - Sin cambios
- `colecciones` - Sin cambios

---

## Cambios Clave desde Fase 1

### 1. Sistema de Pedidos Completo

**Antes (Fase 1)**:

- No había sistema de órdenes
- Stock manual sin trazabilidad

**Después (Fase 2)**:

```sql
-- ✅ Pedido con múltiples productos
pedido_id: 1
├── prenda_id: 5 (Gaia - Jersey Bordó) × 2 unidades
├── prenda_id: 8 (Nube - Frisa Verde) × 1 unidad
└── total: $120,000

-- Automáticamente actualiza stock y auditoría
```

---

### 2. Gestión Automática de Inventario

**Antes (Fase 1)**:

```sql
-- ❌ Manual, propenso a errores
UPDATE prendas SET stock = stock - 2 WHERE prenda_id = 5;
-- ¿Qué pasa si olvidamos restar? ¿Cómo auditamos?
```

**Después (Fase 2)**:

```sql
-- ✅ Sistema automático con trigger
-- Cuando se crea pedido_prenda:
-- 1. Actualiza stock_vendido
-- 2. stock_disponible se recalcula automáticamente
-- 3. Se registra en movimientos_inventario

-- Columna generada (no se puede editar manualmente)
stock_disponible = stock_inicial - stock_vendido
```

---

### 3. Auditoría Completa de Movimientos

**Tabla `movimientos_inventario`** registra:

- ✅ Qué prenda cambió
- ✅ Cuántas unidades
- ✅ Stock antes y después
- ✅ Motivo del cambio
- ✅ Quién/qué lo causó (pedido_prenda_id)
- ✅ Cuándo ocurrió (fecha_movimiento)

**Beneficio**: Trazabilidad completa para auditorías y resolución de problemas.

---

### 4. Disponibilidad Estacional de Telas

**Nueva Funcionalidad**:

```sql
-- Gestionar qué telas usar en cada temporada
SELECT
    t.nombre AS tela,
    a.numero AS año,
    temp.nombre AS temporada,
    tt.disponible
FROM telas_temporadas tt
JOIN telas t ON tt.tela_id = t.tela_id
JOIN años a ON tt.año_id = a.año_id
JOIN temporadas temp ON tt.temporada_id = temp.temporada_id
WHERE tt.disponible = TRUE
ORDER BY a.numero, temp.nombre, t.nombre;
```

**Ejemplo de Resultado**:

```
tela           | año  | temporada | disponible
---------------+------+-----------+-----------
Jersey Bordó   | 2024 | Verano    | ✅
Plush Naranja  | 2024 | Invierno  | ✅
Modal Hueso    | 2025 | Verano    | ✅
```

---

### 5. Expansión de Tablas

| Métrica                 | Fase 1 | Fase 2 | Cambio      |
| ----------------------- | ------ | ------ | ----------- |
| **Tablas**              | 9      | 12     | +3 (+33%)   |
| **Junction Tables**     | 0      | 2      | +2 (nuevas) |
| **Tablas de Auditoría** | 0      | 1      | +1 (nueva)  |
| **Sistema E-commerce**  | ❌     | ✅     | Completo    |

---

## Resumen de Ejecución

### Proceso de Setup (7 Scripts)

1. **`00_db.js`**: Orquestador maestro
2. **`01_crear_database.js`**: Crea `chamana_db_fase2`
3. **`02_crear_tablas.js`**: Crea 12 tablas + triggers
4. **`03_crear_indices.js`**: Índices para performance
5. **`04_migrar_datos_fase1.js`**: Migra desde Fase 1
6. **`05_inicializar_telas_temporadas.js`**: Carga disponibilidad estacional
7. **`06_generar_pedidos_prueba.js`**: Genera pedidos de prueba
8. **`07_verificar.js`**: Verifica sistema completo

### Resultados de Setup

**Sistema E-commerce Operativo**:

- ✅ 31 prendas con inventario automático
- ✅ 20 clientes activos
- ✅ 25+ telas con disponibilidad estacional
- ✅ Pedidos de prueba generados
- ✅ Triggers funcionando (actualización automática)
- ✅ Auditoría registrando movimientos

**Performance**:

- ✅ Índices creados en FKs
- ✅ Queries optimizadas
- ✅ Constraints de integridad activos

---

## Lecciones Aprendidas

### Éxitos

1. **Integridad de Datos Garantizada**

   - Columnas generadas eliminan inconsistencias
   - Triggers automatizan procesos críticos
   - Constraints previenen datos inválidos

2. **Trazabilidad Completa**

   - Cada movimiento de stock registrado
   - Auditoría para resolución de conflictos
   - Histórico completo de operaciones

3. **Escalabilidad Lograda**
   - Sistema listo para producción
   - Junction tables permiten relaciones complejas
   - Fácil agregar nuevas funcionalidades

### Desafíos Encontrados

1. **Complejidad de Triggers**

   - Lógica de negocio en base de datos
   - Debugging más difícil que código aplicación
   - Requiere conocimiento avanzado de PostgreSQL

2. **Queries Más Complejos**

   - Más JOINs necesarios
   - Performance crítica con crecimiento de datos
   - Necesidad de índices bien pensados

3. **Migración de Datos**
   - Transformar `stock` a `stock_inicial`/`stock_vendido`
   - Asumir `stock_vendido = 0` (inicio limpio)
   - Datos históricos se pierden sin auditoría previa

---

## Diagramas

- [Diagrama MER Fase 2](../blob/main/diagramas/fase2/01_MER_Fase2.md) - Modelo Conceptual
- [Diagrama DER Fase 2](../blob/main/diagramas/fase2/02_DER_Fase2.md) - Modelo Lógico
- [Comparación Fase 1 vs Fase 2](../blob/main/diagramas/comparaciones/02_Fase1_vs_Fase2.md)

---

## Ejemplos de Código

### Query: Crear Pedido Completo

```sql
BEGIN;

-- 1. Crear pedido
INSERT INTO pedidos (cliente_id, estado, total)
VALUES (1, 'pendiente', 120000)
RETURNING pedido_id;  -- Supongamos que retorna 101

-- 2. Agregar productos al pedido
INSERT INTO pedidos_prendas (pedido_id, prenda_id, cantidad, precio_unitario, subtotal)
VALUES
    (101, 5, 2, 40000, 80000),   -- Gaia - Jersey Bordó × 2
    (101, 8, 1, 40000, 40000);   -- Nube - Frisa Verde × 1

-- 3. El trigger automáticamente:
--    - Actualiza stock_vendido en prendas
--    - Recalcula stock_disponible
--    - Registra en movimientos_inventario

COMMIT;
```

### Query: Verificar Stock Disponible

```sql
SELECT
    CONCAT(d.nombre, ' - ', t.nombre) AS producto,
    p.stock_inicial,
    p.stock_vendido,
    p.stock_disponible,  -- Columna generada automáticamente
    CASE
        WHEN p.stock_disponible > 0 THEN '✅ Disponible'
        ELSE '❌ Agotado'
    END AS estado
FROM prendas p
JOIN disenos d ON p.diseno_id = d.diseno_id
JOIN telas t ON p.tela_id = t.tela_id
WHERE p.activo = TRUE
ORDER BY p.stock_disponible DESC;
```

### Query: Auditoría de Movimientos

```sql
SELECT
    mi.fecha_movimiento,
    CONCAT(d.nombre, ' - ', t.nombre) AS producto,
    mi.tipo_movimiento,
    mi.cantidad,
    mi.stock_anterior,
    mi.stock_nuevo,
    mi.motivo
FROM movimientos_inventario mi
JOIN prendas p ON mi.prenda_id = p.prenda_id
JOIN disenos d ON p.diseno_id = d.diseno_id
JOIN telas t ON p.tela_id = t.tela_id
WHERE mi.fecha_movimiento >= CURRENT_DATE - INTERVAL '7 days'
ORDER BY mi.fecha_movimiento DESC;
```

### Query: Telas Disponibles por Temporada

```sql
SELECT
    t.nombre AS tela,
    t.tipo_tela,
    t.color,
    a.numero AS año,
    temp.nombre AS temporada
FROM telas_temporadas tt
JOIN telas t ON tt.tela_id = t.tela_id
JOIN años a ON tt.año_id = a.año_id
JOIN temporadas temp ON tt.temporada_id = temp.temporada_id
WHERE tt.disponible = TRUE
    AND a.numero = 2025
    AND temp.nombre = 'Verano'
ORDER BY t.tipo_tela, t.color;
```

---

## Triggers Implementados

### 1. Trigger: Actualizar Stock en Pedido

```sql
CREATE OR REPLACE FUNCTION actualizar_stock_pedido()
RETURNS TRIGGER AS $$
BEGIN
    -- Actualizar stock_vendido cuando se agrega item a pedido
    UPDATE prendas
    SET stock_vendido = stock_vendido + NEW.cantidad
    WHERE prenda_id = NEW.prenda_id;

    -- Registrar movimiento en auditoría
    INSERT INTO movimientos_inventario (
        prenda_id, tipo_movimiento, cantidad,
        stock_anterior, stock_nuevo, motivo, pedido_prenda_id
    )
    SELECT
        NEW.prenda_id,
        'salida',
        NEW.cantidad,
        stock_disponible + NEW.cantidad,  -- Stock antes
        stock_disponible,                 -- Stock después
        'Venta - Pedido #' || NEW.pedido_id,
        NEW.pedido_prenda_id
    FROM prendas
    WHERE prenda_id = NEW.prenda_id;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_actualizar_stock
AFTER INSERT ON pedidos_prendas
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_pedido();
```

---

## Cómo Ejecutar Esta Fase

### Prerequisitos

- Fase 1 completada (para migración)
- PostgreSQL 15+
- Node.js 18+

### Setup Completo

```bash
# 1. Navegar a scripts
cd 2.relaciones/database/scripts

# 2. Instalar dependencias
npm install

# 3. Ejecutar script maestro
node 00_db.js

# 4. Verificar sistema
node 07_verificar.js
```

### Ejecutar Aplicación Web

```bash
cd ../../web
npm install
npm start
# http://localhost:3000
```

---

## Próxima Fase

**[Fase 3: Tercera Forma Normal (3NF)](2.4.Phase-3-Third-Normal)** _(En progreso)_

### Qué Viene

- ✅ Eliminar dependencias transitivas
- ✅ Vistas materializadas para performance
- ✅ Stored procedures para operaciones complejas
- ✅ Índices avanzados y optimización de queries
- ✅ Sistema de autenticación y roles

**Transformación**: 12 tablas (2NF) → 15+ tablas (3NF) con optimización completa

---

## Enlaces Relacionados

- [← Volver al Inicio del Wiki](Home)
- [← Fase Anterior: Fase 1 (1NF)](2.2.Fase-1-Primera-Forma-Normal)
- [→ Siguiente: Fase 3 (3NF)](2.4.Phase-3-Third-Normal) _(Próximamente)_
- [📊 Ver Diagramas de Esta Fase](../tree/main/diagramas/fase2)
- [🔄 Guía de Migración Fase 1 → Fase 2](3.2.Migration-Guides#fase-1-a-fase-2)
- [📚 Documentación Completa de Esquemas](3.1.Documentacion-Esquemas)

---

**Última Actualización**: 23 de Octubre, 2025  
**Estado**: ✅ Completa y funcional  
**Base de Datos**: `chamana_db_fase2`  
**Forma Normal**: 2NF (Segunda Forma Normal)  
**Sistema E-commerce**: ✅ Operativo

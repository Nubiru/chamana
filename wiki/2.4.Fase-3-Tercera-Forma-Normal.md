# Fase 3: Tercera Forma Normal (3NF) + Vistas y Procedimientos

## Objetivo

Aplicar **Tercera Forma Normal (3NF)** eliminando dependencias transitivas y agregar capacidades avanzadas de base de datos:

- ✅ **5 Vistas de Business Intelligence** para análisis y reportes
- ✅ **3 Procedimientos Almacenados** para lógica de negocio compleja
- ✅ **3 Triggers Automáticos** para auditoría y automatización
- ✅ **Aplicación Web** profesional con Express.js y Bootstrap 5

### Criterios de 3NF

Una tabla está en 3NF si:

1. ✅ **Está en 2NF** (sin dependencias parciales)
2. ✅ **No hay dependencias transitivas** (ningún atributo no-clave depende de otro atributo no-clave)
3. ✅ **Solo dependencias directas** (todos los atributos no-clave dependen directamente de la clave primaria)

---

## Esquema de Base de Datos

**Nombre de Base de Datos**: `chamana_db_fase3`  
**Forma Normal**: 3NF (Tercera Forma Normal)  
**Tablas**: 19 (expansión desde 12 en Fase 2)

### Nuevas Tablas 3NF (+7)

#### 1. `direcciones` - Direcciones de Clientes

Elimina dependencia transitiva: `cliente_id → direccion → ciudad, estado, codigo_postal`

```sql
CREATE TABLE direcciones (
  id SERIAL PRIMARY KEY,
  cliente_id INTEGER NOT NULL REFERENCES clientes(id) ON DELETE CASCADE,
  tipo VARCHAR(20) CHECK (tipo IN ('envio', 'facturacion', 'principal')),
  direccion TEXT NOT NULL,
  ciudad VARCHAR(100) NOT NULL,
  estado VARCHAR(100),
  codigo_postal VARCHAR(10),
  pais VARCHAR(50) DEFAULT 'México',
  predeterminada BOOLEAN DEFAULT FALSE,
  activa BOOLEAN DEFAULT TRUE,
  fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Ventajas**:
- Un cliente puede tener múltiples direcciones
- Direcciones reutilizables (misma ciudad/CP no se duplica)
- Historial de direcciones (activa/inactiva)

#### 2. `tipos_prenda` - Catálogo de Tipos de Prenda

Elimina dependencia transitiva: `prenda_id → tipo → descripcion_tipo, cuidados`

```sql
CREATE TABLE tipos_prenda (
  id SERIAL PRIMARY KEY,
  nombre VARCHAR(50) NOT NULL UNIQUE,
  descripcion TEXT,
  cuidados TEXT,
  temperatura_lavado VARCHAR(50),
  fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Ventajas**:
- Catálogo centralizado de tipos
- Fácil agregar nuevos tipos sin modificar prendas
- Consistencia en nombres

#### 3. `estados_pedido` - Estados Normalizados de Pedidos

Elimina dependencia transitiva: `pedido_id → estado → descripcion_estado, workflow`

```sql
CREATE TABLE estados_pedido (
  id SERIAL PRIMARY KEY,
  codigo VARCHAR(20) NOT NULL UNIQUE,
  nombre VARCHAR(50) NOT NULL,
  descripcion TEXT,
  es_inicial BOOLEAN DEFAULT FALSE,
  es_final BOOLEAN DEFAULT FALSE,
  orden_workflow INTEGER,
  fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Estados Estándar**:
- `pendiente` - Orden creada, esperando confirmación
- `confirmado` - Orden confirmada, preparando envío
- `en_proceso` - En proceso de preparación
- `enviado` - Paquete en tránsito
- `entregado` - Orden completada
- `cancelado` - Orden cancelada
- `devuelto` - Orden devuelta

#### 4. `historial_estados_pedido` - Auditoría de Cambios de Estado

```sql
CREATE TABLE historial_estados_pedido (
  id SERIAL PRIMARY KEY,
  pedido_id INTEGER NOT NULL REFERENCES pedidos(id) ON DELETE CASCADE,
  estado_anterior_id INTEGER REFERENCES estados_pedido(id),
  estado_nuevo_id INTEGER NOT NULL REFERENCES estados_pedido(id),
  fecha_cambio TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  usuario_cambio VARCHAR(100),
  automatico BOOLEAN DEFAULT FALSE,
  notas TEXT
);
```

**Ventajas**:
- Trazabilidad completa de cambios
- Auditoría de quién y cuándo cambió el estado
- Soporte para cambios automáticos (triggers)

#### 5. `metodos_pago` - Catálogo de Métodos de Pago

Elimina dependencia transitiva: `pedido_id → metodo_pago → comision, configuracion`

```sql
CREATE TABLE metodos_pago (
  id SERIAL PRIMARY KEY,
  codigo VARCHAR(20) NOT NULL UNIQUE,
  nombre VARCHAR(50) NOT NULL,
  tipo VARCHAR(20) CHECK (tipo IN ('efectivo', 'tarjeta', 'transferencia', 'digital')),
  comision DECIMAL(5,2) DEFAULT 0,
  activo BOOLEAN DEFAULT TRUE,
  orden INTEGER DEFAULT 0,
  fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Métodos Estándar**:
- `efectivo` - Pago en efectivo
- `tarjeta_credito` - Tarjeta de crédito
- `tarjeta_debito` - Tarjeta de débito
- `transferencia` - Transferencia bancaria
- `paypal` - PayPal
- `stripe` - Stripe

#### 6. `proveedores` - Proveedores de Telas

```sql
CREATE TABLE proveedores (
  id SERIAL PRIMARY KEY,
  nombre VARCHAR(100) NOT NULL,
  contacto VARCHAR(100),
  telefono VARCHAR(20),
  email VARCHAR(100),
  direccion TEXT,
  activo BOOLEAN DEFAULT TRUE,
  fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 7. `telas_proveedores` - Relación N:M entre Telas y Proveedores

```sql
CREATE TABLE telas_proveedores (
  id SERIAL PRIMARY KEY,
  tela_id INTEGER NOT NULL REFERENCES telas(id) ON DELETE CASCADE,
  proveedor_id INTEGER NOT NULL REFERENCES proveedores(id) ON DELETE CASCADE,
  precio_unitario DECIMAL(10,2),
  moneda VARCHAR(3) DEFAULT 'MXN',
  fecha_actualizacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(tela_id, proveedor_id)
);
```

---

## Vistas de Business Intelligence

### 1. `vista_ventas_mensuales`

Análisis de ventas agrupadas por mes.

```sql
CREATE VIEW vista_ventas_mensuales AS
SELECT
  DATE_TRUNC('month', p.fecha_pedido) as mes,
  COUNT(DISTINCT p.id) as total_pedidos,
  COUNT(DISTINCT p.cliente_id) as clientes_unicos,
  SUM(pp.cantidad) as prendas_vendidas,
  SUM(p.subtotal) as subtotal_mes,
  SUM(p.descuento) as descuentos_mes,
  SUM(p.total) as total_mes,
  ROUND(AVG(p.total), 2) as ticket_promedio
FROM pedidos p
JOIN pedidos_prendas pp ON p.id = pp.pedido_id
WHERE p.estado_id IN (SELECT id FROM estados_pedido WHERE codigo IN ('enviado', 'entregado'))
GROUP BY DATE_TRUNC('month', p.fecha_pedido)
ORDER BY mes DESC;
```

### 2. `vista_inventario_critico`

Alertas de inventario con niveles de stock categorizados.

```sql
CREATE VIEW vista_inventario_critico AS
SELECT
  p.id,
  p.nombre,
  p.stock_disponible,
  p.stock_vendido,
  p.stock_inicial,
  c.nombre as categoria,
  tp.nombre as tipo_prenda,
  CASE
    WHEN p.stock_disponible = 0 THEN 'AGOTADO'
    WHEN p.stock_disponible <= 3 THEN 'CRITICO'
    WHEN p.stock_disponible <= 10 THEN 'BAJO'
    ELSE 'NORMAL'
  END as estado_stock,
  p.fecha_ultima_venta
FROM prendas p
JOIN categorias c ON p.categoria_id = c.id
JOIN tipos_prenda tp ON p.tipo_prenda_id = tp.id
WHERE p.activa = TRUE
ORDER BY p.stock_disponible, p.fecha_ultima_venta DESC NULLS LAST;
```

### 3. `vista_top_productos`

Top productos más vendidos con análisis de rendimiento.

```sql
CREATE VIEW vista_top_productos AS
SELECT
  p.id,
  p.nombre,
  tp.nombre as tipo_prenda,
  c.nombre as categoria,
  COUNT(pp.id) as veces_vendido,
  SUM(pp.cantidad) as unidades_vendidas,
  SUM(pp.subtotal) as ingresos_totales,
  ROUND(AVG(pp.precio_unitario), 2) as precio_promedio
FROM prendas p
JOIN pedidos_prendas pp ON p.id = pp.prenda_id
JOIN pedidos ped ON pp.pedido_id = ped.id
JOIN tipos_prenda tp ON p.tipo_prenda_id = tp.id
JOIN categorias c ON p.categoria_id = c.id
WHERE ped.estado_id IN (SELECT id FROM estados_pedido WHERE codigo IN ('enviado', 'entregado'))
GROUP BY p.id, p.nombre, tp.nombre, c.nombre
ORDER BY unidades_vendidas DESC;
```

### 4. `vista_analisis_clientes`

Segmentación de clientes por valor y comportamiento.

```sql
CREATE VIEW vista_analisis_clientes AS
SELECT
  c.id,
  c.nombre,
  c.email,
  COUNT(DISTINCT p.id) as total_pedidos,
  SUM(p.total) as valor_total_compras,
  ROUND(AVG(p.total), 2) as ticket_promedio,
  MAX(p.fecha_pedido) as ultima_compra,
  CASE
    WHEN SUM(p.total) >= 5000 THEN 'VIP'
    WHEN SUM(p.total) >= 2000 THEN 'Premium'
    WHEN SUM(p.total) >= 500 THEN 'Regular'
    ELSE 'Nuevo'
  END as segmento
FROM clientes c
LEFT JOIN pedidos p ON c.id = p.cliente_id
WHERE c.activo = TRUE
GROUP BY c.id, c.nombre, c.email
ORDER BY valor_total_compras DESC NULLS LAST;
```

### 5. `vista_rotacion_inventario`

Análisis de rotación de inventario por producto.

```sql
CREATE VIEW vista_rotacion_inventario AS
SELECT
  p.id,
  p.nombre,
  p.stock_inicial,
  p.stock_vendido,
  p.stock_disponible,
  CASE
    WHEN p.stock_inicial > 0 THEN
      ROUND((p.stock_vendido::DECIMAL / p.stock_inicial) * 100, 2)
    ELSE 0
  END as porcentaje_rotacion,
  CASE
    WHEN (p.stock_vendido::DECIMAL / NULLIF(p.stock_inicial, 0)) > 0.8 THEN 'Alta Rotación'
    WHEN (p.stock_vendido::DECIMAL / NULLIF(p.stock_inicial, 0)) > 0.5 THEN 'Media Rotación'
    WHEN (p.stock_vendido::DECIMAL / NULLIF(p.stock_inicial, 0)) > 0.2 THEN 'Baja Rotación'
    ELSE 'Sin Rotación'
  END as clasificacion_rotacion
FROM prendas p
WHERE p.activa = TRUE
ORDER BY porcentaje_rotacion DESC;
```

---

## Procedimientos Almacenados

### 1. `procesar_pedido`

Procesa un pedido completo con validaciones y actualización automática de inventario.

```sql
CREATE OR REPLACE FUNCTION procesar_pedido(
  p_cliente_id INTEGER,
  p_items JSONB,
  p_descuento DECIMAL DEFAULT 0
) RETURNS INTEGER AS $$
DECLARE
  v_pedido_id INTEGER;
  v_subtotal DECIMAL := 0;
  v_total DECIMAL;
  v_item JSONB;
  v_prenda_stock INTEGER;
BEGIN
  -- Validar cliente existe y está activo
  IF NOT EXISTS (SELECT 1 FROM clientes WHERE id = p_cliente_id AND activo = TRUE) THEN
    RAISE EXCEPTION 'Cliente % no existe o está inactivo', p_cliente_id;
  END IF;

  -- Crear pedido
  INSERT INTO pedidos (cliente_id, subtotal, descuento, total, estado_id, fecha_pedido)
  VALUES (
    p_cliente_id, 
    0, 
    p_descuento, 
    0, 
    (SELECT id FROM estados_pedido WHERE codigo = 'pendiente'),
    CURRENT_TIMESTAMP
  )
  RETURNING id INTO v_pedido_id;

  -- Procesar cada item
  FOR v_item IN SELECT * FROM jsonb_array_elements(p_items)
  LOOP
    -- Verificar stock disponible
    SELECT stock_disponible INTO v_prenda_stock
    FROM prendas
    WHERE id = (v_item->>'prenda_id')::INTEGER;

    IF v_prenda_stock IS NULL THEN
      RAISE EXCEPTION 'Prenda ID % no existe', (v_item->>'prenda_id')::INTEGER;
    END IF;

    IF v_prenda_stock < (v_item->>'cantidad')::INTEGER THEN
      RAISE EXCEPTION 'Stock insuficiente para prenda ID %. Disponible: %, Solicitado: %',
        (v_item->>'prenda_id')::INTEGER, v_prenda_stock, (v_item->>'cantidad')::INTEGER;
    END IF;

    -- Insertar item del pedido
    INSERT INTO pedidos_prendas (
      pedido_id, prenda_id, cantidad, precio_unitario, subtotal
    )
    SELECT
      v_pedido_id,
      (v_item->>'prenda_id')::INTEGER,
      (v_item->>'cantidad')::INTEGER,
      precio_chamana,
      precio_chamana * (v_item->>'cantidad')::INTEGER
    FROM prendas
    WHERE id = (v_item->>'prenda_id')::INTEGER;

    -- Actualizar stock
    UPDATE prendas
    SET stock_vendido = stock_vendido + (v_item->>'cantidad')::INTEGER,
        fecha_ultima_venta = CURRENT_TIMESTAMP
    WHERE id = (v_item->>'prenda_id')::INTEGER;

    -- Registrar movimiento de inventario
    INSERT INTO movimientos_inventario (
      prenda_id, tipo, cantidad, stock_anterior, stock_nuevo, pedido_id, motivo, fecha
    )
    SELECT
      id,
      'salida',
      (v_item->>'cantidad')::INTEGER,
      stock_disponible + (v_item->>'cantidad')::INTEGER,
      stock_disponible,
      v_pedido_id,
      'Venta - Pedido ' || v_pedido_id,
      CURRENT_TIMESTAMP
    FROM prendas
    WHERE id = (v_item->>'prenda_id')::INTEGER;

    -- Acumular subtotal
    v_subtotal := v_subtotal + (
      SELECT precio_chamana * (v_item->>'cantidad')::INTEGER
      FROM prendas
      WHERE id = (v_item->>'prenda_id')::INTEGER
    );
  END LOOP;

  -- Calcular total
  v_total := v_subtotal - p_descuento;

  -- Actualizar pedido con totales
  UPDATE pedidos
  SET subtotal = v_subtotal, total = v_total
  WHERE id = v_pedido_id;

  RETURN v_pedido_id;
END;
$$ LANGUAGE plpgsql;
```

**Uso**:
```sql
SELECT procesar_pedido(
  1,
  '[{"prenda_id": 5, "cantidad": 2}, {"prenda_id": 8, "cantidad": 1}]'::JSONB,
  10.00
);
```

### 2. `reabastecer_inventario`

Reabastece inventario con auditoría completa.

```sql
CREATE OR REPLACE FUNCTION reabastecer_inventario(
  p_prenda_id INTEGER,
  p_cantidad INTEGER,
  p_motivo TEXT DEFAULT 'Reposición'
) RETURNS BOOLEAN AS $$
DECLARE
  v_stock_anterior INTEGER;
  v_stock_nuevo INTEGER;
BEGIN
  -- Validar prenda existe
  IF NOT EXISTS (SELECT 1 FROM prendas WHERE id = p_prenda_id) THEN
    RAISE EXCEPTION 'Prenda ID % no existe', p_prenda_id;
  END IF;

  -- Obtener stock actual
  SELECT stock_inicial INTO v_stock_anterior FROM prendas WHERE id = p_prenda_id;

  -- Actualizar stock inicial
  UPDATE prendas
  SET stock_inicial = stock_inicial + p_cantidad
  WHERE id = p_prenda_id;

  -- Obtener nuevo stock (stock_disponible se recalcula automáticamente)
  SELECT stock_disponible INTO v_stock_nuevo FROM prendas WHERE id = p_prenda_id;

  -- Registrar movimiento
  INSERT INTO movimientos_inventario (
    prenda_id, tipo, cantidad, stock_anterior, stock_nuevo, motivo, fecha
  )
  VALUES (
    p_prenda_id,
    'entrada',
    p_cantidad,
    v_stock_anterior,
    v_stock_nuevo,
    p_motivo,
    CURRENT_TIMESTAMP
  );

  RETURN TRUE;
END;
$$ LANGUAGE plpgsql;
```

### 3. `calcular_comision_vendedor`

Calcula comisiones de vendedores en un período.

```sql
CREATE OR REPLACE FUNCTION calcular_comision_vendedor(
  p_fecha_inicio DATE,
  p_fecha_fin DATE,
  p_porcentaje_comision DECIMAL
) RETURNS TABLE (
  vendedor_id INTEGER,
  vendedor_nombre VARCHAR,
  total_ventas DECIMAL,
  comision DECIMAL
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    a.id as vendedor_id,
    a.nombre as vendedor_nombre,
    COALESCE(SUM(p.total), 0) as total_ventas,
    COALESCE(SUM(p.total) * (p_porcentaje_comision / 100), 0) as comision
  FROM artesanos a
  LEFT JOIN prendas pr ON a.id = pr.artesano_id
  LEFT JOIN pedidos_prendas pp ON pr.id = pp.prenda_id
  LEFT JOIN pedidos p ON pp.pedido_id = p.id
  WHERE p.fecha_pedido BETWEEN p_fecha_inicio AND p_fecha_fin
    AND p.estado_id IN (SELECT id FROM estados_pedido WHERE codigo IN ('enviado', 'entregado'))
  GROUP BY a.id, a.nombre
  ORDER BY total_ventas DESC;
END;
$$ LANGUAGE plpgsql;
```

---

## Triggers Automáticos

### 1. `trigger_track_order_state`

Rastrea cambios de estado en pedidos automáticamente.

```sql
CREATE OR REPLACE FUNCTION track_order_state_change()
RETURNS TRIGGER AS $$
BEGIN
  IF OLD.estado_id IS DISTINCT FROM NEW.estado_id THEN
    INSERT INTO historial_estados_pedido (
      pedido_id, estado_anterior_id, estado_nuevo_id, usuario_cambio, automatico
    )
    VALUES (
      NEW.id,
      OLD.estado_id,
      NEW.estado_id,
      current_user,
      FALSE
    );

    RAISE NOTICE 'Pedido % cambió de estado: % → %', 
      NEW.id, 
      (SELECT codigo FROM estados_pedido WHERE id = OLD.estado_id),
      (SELECT codigo FROM estados_pedido WHERE id = NEW.estado_id);
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_track_order_state
AFTER UPDATE ON pedidos
FOR EACH ROW
WHEN (OLD.estado_id IS DISTINCT FROM NEW.estado_id)
EXECUTE FUNCTION track_order_state_change();
```

### 2. `trigger_stock_alert`

Genera alertas cuando el stock baja a niveles críticos.

```sql
CREATE OR REPLACE FUNCTION check_stock_alert()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.stock_disponible <= 5 AND NEW.stock_disponible < OLD.stock_disponible THEN
    RAISE NOTICE 'ALERTA: Stock crítico para prenda "%" (ID: %) - Solo % unidades disponibles',
                 NEW.nombre, NEW.id, NEW.stock_disponible;
  END IF;

  IF NEW.stock_disponible = 0 AND OLD.stock_disponible > 0 THEN
    RAISE WARNING 'AGOTADO: Prenda "%" (ID: %) se ha agotado completamente',
                  NEW.nombre, NEW.id;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_stock_alert
AFTER UPDATE ON prendas
FOR EACH ROW
WHEN (OLD.stock_disponible IS DISTINCT FROM NEW.stock_disponible)
EXECUTE FUNCTION check_stock_alert();
```

### 3. `trigger_manage_default_address`

Gestiona automáticamente direcciones predeterminadas (solo una por cliente).

```sql
CREATE OR REPLACE FUNCTION manage_default_address()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.predeterminada = TRUE THEN
    -- Desactivar otras direcciones predeterminadas del mismo cliente
    UPDATE direcciones
    SET predeterminada = FALSE
    WHERE cliente_id = NEW.cliente_id
      AND id != NEW.id
      AND predeterminada = TRUE;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_manage_default_address
BEFORE INSERT OR UPDATE ON direcciones
FOR EACH ROW
EXECUTE FUNCTION manage_default_address();
```

---

## Comparación con Fase 2

| Aspecto | Fase 2 (2NF) | Fase 3 (3NF) | Mejora |
|---------|--------------|--------------|--------|
| **Tablas** | 12 | 19 | +7 tablas normalizadas |
| **Normalización** | 2NF | 3NF | ✅ Sin dependencias transitivas |
| **Vistas** | 0 | 5 | ✅ Business Intelligence |
| **Procedimientos** | 0 | 3 | ✅ Lógica en DB |
| **Triggers** | 0 | 3 | ✅ Automatización |
| **Redundancia** | ~20% | 0% | ✅ Eliminada |
| **Integridad** | Alta | Muy Alta | ✅ Auditoría completa |

---

## Instalación

### Prerrequisitos

- PostgreSQL 12+
- Node.js 18+
- npm o yarn

### Pasos

1. **Crear base de datos**:
```bash
cd 3.vistas-y-procedimientos/database/scripts
npm install
node 01_crear_database.js
```

2. **Crear tablas**:
```bash
node 02_crear_tablas.js
```

3. **Insertar datos iniciales**:
```bash
node 03_insertar_datos_iniciales.js
```

4. **Migrar datos de Fase 2**:
```bash
node 04_migrar_datos_fase2.js
```

5. **Crear vistas**:
```bash
node 05_crear_vistas.js
```

6. **Crear procedimientos**:
```bash
node 06_crear_procedimientos.js
```

7. **Crear triggers**:
```bash
node 07_crear_triggers.js
```

8. **Verificar implementación**:
```bash
node 09_verificar.js
```

---

## Uso

### Consultar Vistas

```sql
-- Ventas mensuales
SELECT * FROM vista_ventas_mensuales;

-- Inventario crítico
SELECT * FROM vista_inventario_critico WHERE estado_stock = 'CRITICO';

-- Top productos
SELECT * FROM vista_top_productos LIMIT 10;

-- Análisis de clientes
SELECT * FROM vista_analisis_clientes WHERE segmento = 'VIP';

-- Rotación de inventario
SELECT * FROM vista_rotacion_inventario WHERE clasificacion_rotacion = 'Alta Rotación';
```

### Usar Procedimientos

```sql
-- Procesar pedido
SELECT procesar_pedido(
  1,
  '[{"prenda_id": 5, "cantidad": 2}]'::JSONB,
  10.00
);

-- Reabastecer inventario
SELECT reabastecer_inventario(5, 20, 'Reposición semanal');

-- Calcular comisiones
SELECT * FROM calcular_comision_vendedor(
  '2024-01-01'::DATE,
  '2024-01-31'::DATE,
  5.0
);
```

---

## Referencias

- [Diagramas MER/DER Fase 3](../diagramas/fase3/)
- [Comparación Fase 2 vs Fase 3](../diagramas/comparaciones/03_Fase2_vs_Fase3.md)
- [Documentación Técnica](3.1.Documentacion-Esquemas)
- [Guías de Migración](3.2.Guias-Migracion)

---

**Última Actualización**: Noviembre 2025  
**Autor**: Gabriel Osemberg


# Documentación de Esquemas

## Resumen General

Esta página documenta todos los esquemas de base de datos a través de las fases de normalización. Cada fase utiliza una base de datos independiente para permitir comparación side-by-side.

**Bases de Datos**:

- `chamana_db_fase0` - Pre-normalizado (3 tablas)
- `chamana_db_fase1` - Primera Forma Normal (9 tablas)
- `chamana_db_fase2` - Segunda Forma Normal (12 tablas)

---

## Fase 0: Pre-Normalizado

### Características Generales

- **Tablas**: 3
- **Forma Normal**: Pre-normalizado (~1NF parcial)
- **Redundancia**: Intencional (propósitos pedagógicos)

### Tabla: `clientes`

```sql
CREATE TABLE clientes (
    cliente_id SERIAL PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    apellido VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    telefono VARCHAR(20),
    fecha_registro TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    activo BOOLEAN DEFAULT TRUE
);
```

**Descripción**: Información simplificada de clientes (solo comunicación).

**Constraints**:

- PK: `cliente_id`
- UNIQUE: `email`
- NOT NULL: `nombre`, `apellido`, `email`

---

### Tabla: `categorias`

```sql
CREATE TABLE categorias (
    categoria_id SERIAL PRIMARY KEY,
    nombre VARCHAR(50) UNIQUE NOT NULL,
    descripcion TEXT,
    activo BOOLEAN DEFAULT TRUE
);
```

**Descripción**: Categorías de productos (Buzo, Remera, Vestido, Palazzo, Pantalón).

**Constraints**:

- PK: `categoria_id`
- UNIQUE: `nombre`
- NOT NULL: `nombre`

---

### Tabla: `prendas`

```sql
CREATE TABLE prendas (
    prenda_id SERIAL PRIMARY KEY,
    nombre_completo VARCHAR(100) NOT NULL,  -- ⚠️ PROBLEMA: Valor compuesto
    categoria_id INTEGER REFERENCES categorias(categoria_id),
    tela_nombre VARCHAR(100),                -- ⚠️ PROBLEMA: Redundancia
    precio_chamana DECIMAL(10,2) NOT NULL,
    precio_arro DECIMAL(10,2),
    descuento_porcentaje DECIMAL(5,2),
    stock INTEGER DEFAULT 0,
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    activo BOOLEAN DEFAULT TRUE
);
```

**Descripción**: Productos del catálogo con redundancia intencional.

**Constraints**:

- PK: `prenda_id`
- FK: `categoria_id` → `categorias(categoria_id)`
- NOT NULL: `nombre_completo`, `precio_chamana`

**Problemas Intencionales**:

- `nombre_completo`: Combina diseño + tela (no atómico)
- `tela_nombre`: Repite valores (redundancia)

---

## Fase 1: Primera Forma Normal (1NF)

### Características Generales

- **Tablas**: 9
- **Forma Normal**: 1NF
- **Mejoras**: Valores atómicos, redundancia eliminada

### Tablas Nuevas en Fase 1

#### `disenos`

```sql
CREATE TABLE disenos (
    diseno_id SERIAL PRIMARY KEY,
    nombre VARCHAR(50) UNIQUE NOT NULL,
    descripcion TEXT,
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    activo BOOLEAN DEFAULT TRUE
);
```

**Propósito**: Separar concepto de diseño (Gaia, Nube, Tormenta, etc.).

---

#### `telas`

```sql
CREATE TABLE telas (
    tela_id SERIAL PRIMARY KEY,
    nombre VARCHAR(100) UNIQUE NOT NULL,
    tipo_tela VARCHAR(50),
    color VARCHAR(50),
    descripcion TEXT,
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    activo BOOLEAN DEFAULT TRUE
);
```

**Propósito**: Eliminar redundancia de `tela_nombre`.

**Ejemplo de Datos**:

```
tela_id | nombre          | tipo_tela | color
--------+-----------------+-----------+-------
1       | Jersey Bordó    | Jersey    | Bordó
2       | Plush Verde     | Plush     | Verde
3       | Coral Negro     | Coral     | Negro
```

---

#### `años`

```sql
CREATE TABLE años (
    año_id SERIAL PRIMARY KEY,
    numero INTEGER UNIQUE NOT NULL,
    activo BOOLEAN DEFAULT TRUE
);
```

**Propósito**: Organizar colecciones por año.

---

#### `temporadas`

```sql
CREATE TABLE temporadas (
    temporada_id SERIAL PRIMARY KEY,
    nombre VARCHAR(20) UNIQUE NOT NULL,
    descripcion TEXT,
    activo BOOLEAN DEFAULT TRUE
);
```

**Propósito**: Clasificar colecciones estacionales.

**Datos Estándar**: Verano, Invierno, Otoño, Primavera

---

#### `colecciones`

```sql
CREATE TABLE colecciones (
    coleccion_id SERIAL PRIMARY KEY,
    nombre VARCHAR(100) UNIQUE NOT NULL,
    año_id INTEGER REFERENCES años(año_id),
    temporada_id INTEGER REFERENCES temporadas(temporada_id),
    fecha_inicio DATE,
    fecha_fin DATE,
    descripcion TEXT,
    activo BOOLEAN DEFAULT TRUE
);
```

**Propósito**: Agrupar prendas por colección estacional.

**Ejemplo**: "Verano 2024", "Invierno 2025"

---

### Tabla Modificada: `prendas` (Fase 1)

```sql
CREATE TABLE prendas (
    prenda_id SERIAL PRIMARY KEY,
    diseno_id INTEGER REFERENCES disenos(diseno_id),       -- ✅ FK nueva
    tela_id INTEGER REFERENCES telas(tela_id),             -- ✅ FK nueva
    categoria_id INTEGER REFERENCES categorias(categoria_id),
    coleccion_id INTEGER REFERENCES colecciones(coleccion_id), -- ✅ FK nueva
    precio_chamana DECIMAL(10,2) NOT NULL,
    precio_arro DECIMAL(10,2),
    descuento_porcentaje DECIMAL(5,2),
    stock INTEGER DEFAULT 0,
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    activo BOOLEAN DEFAULT TRUE,
    UNIQUE(diseno_id, tela_id)                             -- ✅ Constraint nueva
);
```

**Cambios desde Fase 0**:

- ❌ Removido: `nombre_completo`, `tela_nombre`
- ✅ Añadido: `diseno_id`, `tela_id`, `coleccion_id`

---

## Fase 2: Segunda Forma Normal (2NF)

### Características Generales

- **Tablas**: 12
- **Forma Normal**: 2NF
- **Mejoras**: Junction tables, inventario automático, auditoría

### Tablas Nuevas en Fase 2

#### `pedidos`

```sql
CREATE TABLE pedidos (
    pedido_id SERIAL PRIMARY KEY,
    cliente_id INTEGER REFERENCES clientes(cliente_id),
    fecha_pedido TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    estado VARCHAR(20) DEFAULT 'pendiente',
    total DECIMAL(10,2),
    notas TEXT,
    fecha_actualizacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Propósito**: Gestionar órdenes de compra.

**Estados**: `pendiente`, `confirmado`, `enviado`, `entregado`, `cancelado`

---

#### `pedidos_prendas` (Junction Table)

```sql
CREATE TABLE pedidos_prendas (
    pedido_prenda_id SERIAL PRIMARY KEY,
    pedido_id INTEGER REFERENCES pedidos(pedido_id),
    prenda_id INTEGER REFERENCES prendas(prenda_id),
    cantidad INTEGER NOT NULL CHECK (cantidad > 0),
    precio_unitario DECIMAL(10,2) NOT NULL,
    subtotal DECIMAL(10,2),
    fecha_agregado TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(pedido_id, prenda_id)
);
```

**Propósito**: Relación N:M entre pedidos y prendas.

**Razón 2NF**: Evita dependencias parciales con clave compuesta.

---

#### `movimientos_inventario`

```sql
CREATE TABLE movimientos_inventario (
    movimiento_id SERIAL PRIMARY KEY,
    prenda_id INTEGER REFERENCES prendas(prenda_id),
    tipo_movimiento VARCHAR(20) NOT NULL,
    cantidad INTEGER NOT NULL,
    stock_anterior INTEGER NOT NULL,
    stock_nuevo INTEGER NOT NULL,
    motivo TEXT,
    pedido_prenda_id INTEGER REFERENCES pedidos_prendas(pedido_prenda_id),
    fecha_movimiento TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Propósito**: Auditoría completa de movimientos de stock.

**Tipos**: `entrada`, `salida`, `ajuste`

---

#### `telas_temporadas` (Junction Table)

```sql
CREATE TABLE telas_temporadas (
    tela_temporada_id SERIAL PRIMARY KEY,
    tela_id INTEGER REFERENCES telas(tela_id),
    año_id INTEGER REFERENCES años(año_id),
    temporada_id INTEGER REFERENCES temporadas(temporada_id),
    disponible BOOLEAN DEFAULT TRUE,
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(tela_id, año_id, temporada_id)
);
```

**Propósito**: Gestionar disponibilidad estacional de telas.

---

### Tabla Modificada: `prendas` (Fase 2)

```sql
CREATE TABLE prendas (
    prenda_id SERIAL PRIMARY KEY,
    diseno_id INTEGER REFERENCES disenos(diseno_id),
    tela_id INTEGER REFERENCES telas(tela_id),
    categoria_id INTEGER REFERENCES categorias(categoria_id),
    coleccion_id INTEGER REFERENCES colecciones(coleccion_id),
    precio_chamana DECIMAL(10,2) NOT NULL,
    precio_arro DECIMAL(10,2),
    descuento_porcentaje DECIMAL(5,2),

    -- ✅ NUEVO: Sistema de inventario automático
    stock_inicial INTEGER DEFAULT 0,
    stock_vendido INTEGER DEFAULT 0,
    stock_disponible INTEGER GENERATED ALWAYS AS (stock_inicial - stock_vendido) STORED,

    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    activo BOOLEAN DEFAULT TRUE,
    UNIQUE(diseno_id, tela_id)
);
```

**Cambios desde Fase 1**:

- ❌ Removido: `stock` (manual, propenso a errores)
- ✅ Añadido: `stock_inicial`, `stock_vendido`, `stock_disponible` (columna generada)

---

## Comparación de Esquemas

### Evolución de Tablas

| Fase   | Tablas | Forma Normal | Características Principales                       |
| ------ | ------ | ------------ | ------------------------------------------------- |
| Fase 0 | 3      | Pre-norm     | Redundancia intencional, valores compuestos       |
| Fase 1 | 9      | 1NF          | Valores atómicos, redundancia eliminada           |
| Fase 2 | 12     | 2NF          | Junction tables, inventario automático, auditoría |

### Evolución de `prendas`

| Fase   | Columnas | Claves Foráneas                        | Características Especiales        |
| ------ | -------- | -------------------------------------- | --------------------------------- |
| Fase 0 | 10       | 1 (categoria_id)                       | nombre_completo, tela_nombre      |
| Fase 1 | 10       | 4 (diseno, tela, categoria, coleccion) | FKs reemplazan redundancia        |
| Fase 2 | 12       | 4 (sin cambio)                         | Columna generada stock_disponible |

---

## Índices y Optimización

### Índices Automáticos (Claves Primarias)

Todas las PKs tienen índice automático:

- `cliente_id`, `categoria_id`, `prenda_id`, `pedido_id`, etc.

### Índices en Claves Foráneas (Fase 2)

```sql
CREATE INDEX idx_prendas_diseno ON prendas(diseno_id);
CREATE INDEX idx_prendas_tela ON prendas(tela_id);
CREATE INDEX idx_prendas_categoria ON prendas(categoria_id);
CREATE INDEX idx_prendas_coleccion ON prendas(coleccion_id);

CREATE INDEX idx_pedidos_cliente ON pedidos(cliente_id);
CREATE INDEX idx_pedidos_prendas_pedido ON pedidos_prendas(pedido_id);
CREATE INDEX idx_pedidos_prendas_prenda ON pedidos_prendas(prenda_id);

CREATE INDEX idx_movimientos_prenda ON movimientos_inventario(prenda_id);
CREATE INDEX idx_movimientos_pedido_prenda ON movimientos_inventario(pedido_prenda_id);

CREATE INDEX idx_telas_temporadas_tela ON telas_temporadas(tela_id);
CREATE INDEX idx_telas_temporadas_año ON telas_temporadas(año_id);
CREATE INDEX idx_telas_temporadas_temporada ON telas_temporadas(temporada_id);
```

**Propósito**: Acelerar JOINs y búsquedas por FK.

---

## Triggers y Funciones

### Fase 2: Trigger de Actualización de Stock

```sql
CREATE OR REPLACE FUNCTION actualizar_stock_pedido()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE prendas
    SET stock_vendido = stock_vendido + NEW.cantidad
    WHERE prenda_id = NEW.prenda_id;

    INSERT INTO movimientos_inventario (
        prenda_id, tipo_movimiento, cantidad,
        stock_anterior, stock_nuevo, motivo, pedido_prenda_id
    )
    SELECT
        NEW.prenda_id, 'salida', NEW.cantidad,
        stock_disponible + NEW.cantidad,
        stock_disponible,
        'Venta - Pedido #' || NEW.pedido_id,
        NEW.pedido_prenda_id
    FROM prendas
    WHERE prenda_id = NEW.prenda_id;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_actualizar_stock
AFTER INSERT ON pedidos_prendas
FOR EACH ROW
EXECUTE FUNCTION actualizar_stock_pedido();
```

**Propósito**: Automatizar actualización de inventario y auditoría.

---

## Constraints y Reglas de Negocio

### Constraints de Integridad

1. **Claves Primarias**: Todas las tablas tienen PK SERIAL
2. **Claves Foráneas**: Todas las relaciones con FKs
3. **UNIQUE**: Nombres de categorías, diseños, telas, emails, etc.
4. **NOT NULL**: Campos críticos (nombres, precios, cantidades)
5. **CHECK**: Cantidades > 0, estados válidos

### Columnas Generadas

- `prendas.stock_disponible`: Calculado automáticamente
- `pedidos_prendas.subtotal`: Puede calcularse (precio_unitario \* cantidad)

### Default Values

- Timestamps: `CURRENT_TIMESTAMP`
- Booleanos activo: `TRUE`
- Estados: `'pendiente'`
- Cantidades: `0`

---

## Enlaces Relacionados

- [← Volver al Inicio del Wiki](Home)
- [Fase 0: Esquema Pre-normalizado](2.1.Phase-0-Pre-Normalized#esquema-de-base-de-datos)
- [Fase 1: Esquema 1NF](2.2.Phase-1-First-Normal#esquema-de-base-de-datos)
- [Fase 2: Esquema 2NF](2.3.Phase-2-Second-Normal#esquema-de-base-de-datos)
- [Guías de Migración](3.2.Guias-Migracion)
- [Decisiones de Diseño](3.3.Decisiones-Diseno)

---

**Última Actualización**: 23 de Octubre, 2025  
**Fuentes**: Archivos SQL en `database/` de cada fase
